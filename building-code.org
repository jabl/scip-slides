#+Title: Building code
#+Author: Janne Blomqvist

#+OPTIONS: num:nil

* Scope
  - How to go from a bunch of source files to an application?
  - This is about how to compile C/C++/Fortran/etc. code
    - python/R/Matlab etc. extensions have their own ways

* Simple single-file program
  Say you have a program consisting of a single source file:
#+BEGIN_SRC C
#include <stdio.h>
int main() {
    printf("Hello world!");
    return 0;
}
#+END_SRC
  - Compile it with ~gcc -O2 -Wall -g hello.c~
  - This generates a binary called ~a.out~
  - Run it with ~./a.out~
  - Don't like ~a.out~? Choose your own name with ~gcc -o myprog -O2
    -Wall -g hello.c~

* Multiple source files
  - Most non-trivial programs consist of several source files.
  - Separate compilation model: In languages like
    C/C++/Fortran/etc. source files can be compiled separately,
    creating /object/ files (.o). In the end, the object files are
    /linked/ together to create the final binary.
  - Typically you don't run the linker directly, the /compiler driver/
    takes care of it.
#+BEGIN_SRC shell
gcc -c -O2 -g -Wall a.c
gcc -c -O2 -g -Wall b.c
gcc a.o b.o
#+END_SRC

** make
   - If only ~a.c~ has changed, you don't need to recompile
     ~b.c~. It's enough to recompile ~a.c~ and relink the object
     files.
     - For large projects, this saves a lot of time compared to
       recompiling everything all the time.
     - Manually keeping track of what needs to be recompiled is
       tedious and error-prone..
   - *make*: A tool to control how generation of files from other
     files is done.
     - A /makefile/ describes /targets/, /sources/, and /rules/ to
       transform sources into targets
       - When a /source/ file has changed and make is run, it
         regenerates the corresponding /target/ by running specified
         commands.

*** Makefile example
Maybe an example will make this a bit clearer...

#+BEGIN_SRC make
CC=gcc
CFLAGS=-O2 -Wall -g
LDFLAGS=
LDLIBS=-lm
PROGRAM=myprog
OBJS=a.o b.o

$(PROGRAM): $(OBJS)
	$(CC) -o $(PROGRAM) $(OBJS) $(LDFLAGS) $(LDLIBS)

b.o: b.h
a.o: b.h
.PHONY: clean
clean: 
	-rm $(PROGRAM) $(OBJS)
#+END_SRC
Magic: Implicit GNU make rules (don't need to specify source files),
implicit targets for .o files.

** Automake
# #+ATTR_REVEAL: :frag (grow shrink roll-in fade-out none) :frag_idx (4 3 2 1 -)
#+ATTR_REVEAL: :frag (none none appear)
  - But, typically Makefiles tend to contain a lot of boilerplate..
  - Can't we write a tool to generate Makefiles?
  - YES WE CAN!
    - Somebody already did. It's called *automake*
    - Write an automake file, ~Makefile.am~
    - Run automake, and a Makefile is generated

** Autoconf
   - How to compile differently for different target systems?
   - A tool called *autoconf*
     - You write ~configure.ac~
       - autoconf generates a script called ~configure~ that does a
         bunch of tests
       - Running ~configure~ generates a file ~config.h~ that you can
         include in your source

#+BEGIN_SRC C
#ifdef HAVE_FOO
/* Do something */
#endif
#+END_SRC

** Autotools

   - The combination of Autoconf, Automake, and another useful tool
     called libtool, is called *Autotools*.
   - See https://autotools.io for a decent introduction
   - Some people hate autotools
     - Probably the most common autotools alternative is *CMake*
       - Has good and bad points compared to autotools
     - Pick your poison..

*** Autotools exercise

    - "Autotoolify" the simple example with a.c and b.c
    - If you want credits: Email us a .tar.xz file with a project
      folder containing Makefile.am, configure.ac, a.c, b.c, and other
      needed files. Don't include the binaries or object files!
      - Hint: Create the archive with ~tar caf
        $USER-autoexercise.tar.xz directory/~
